module Examples.Raft.Socket.Common where

import Protolude

import qualified Data.ByteString as BS
import qualified Network.Simple.TCP as N
import qualified Network.Socket as NS
import qualified Data.Word8 as W8

import Raft.Types

maxMsgSize :: Int
maxMsgSize = 1000 * 4096

-- | Convert a host and a port to a valid NodeId
hostPortToNid :: (N.HostName, N.ServiceName) -> NodeId
hostPortToNid = toS . hostPortToNidBS

hostPortToNidBS :: (N.HostName, N.ServiceName) -> ByteString
hostPortToNidBS (host, port) = toS $ host ++ ":" ++ toS port

-- | Retrieve the host and port from a valid NodeId
nidToHostPort :: NodeId -> (N.HostName, N.ServiceName)
nidToHostPort bs =
  case BS.split W8._colon bs of
    [host,port] -> (toS host, toS port)
    _ -> panic "nidToHostPort: invalid node id"

-- | Get a free port number.
getFreePort :: IO N.ServiceName
getFreePort = do
  sock <- NS.socket NS.AF_INET NS.Stream NS.defaultProtocol
  NS.bind sock (NS.SockAddrInet NS.aNY_PORT NS.iNADDR_ANY)
  port <- NS.socketPort sock
  NS.close sock
  pure $ show port

recvAll :: N.Socket -> Int -> IO (Maybe ByteString)
recvAll sock size = do
  recvSockM <- N.recv sock size
  case recvSockM of
    Nothing -> pure Nothing
    Just recvSockNow -> do
       mRecvSockLater <- recvAll sock size
       case mRecvSockLater of
         Nothing -> pure $ Just recvSockNow
         Just recvSockLater -> pure . Just $ recvSockNow <> recvSockLater
